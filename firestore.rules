rules_version = "2";
service cloud.firestore {
  match /databases/{database}/documents {

    // At the moment, these rules provide access control, but not data validation.

    function validAuth() {
      return request.auth != null && request.auth.uid != null;
    }

    match /sessions/{session} {

      // Return whether the current user is the teacher hosting this session.
      function isTeacher() {
        // Note, you can only use this function in the base collection, not a
        // subcollection. (If you're in a subcollection, 'resource' doesn't
        // refer to the session anymore.)
        return request.auth.uid == resource.data.hostId;
      }

      // Return whether the current user is a student in this session.
      function isStudent() {
        return exists(/databases/$(database)/documents/sessions/$(session)/students/$(request.auth.uid))
      }

      // A session can be read by the teacher and students
      allow read: if validAuth() && (isTeacher() || isStudent());

      // A session's hostId must equal the uid of the teacher creating it and the createdAt timestamp must be correct.
      allow create: if validAuth() && request.auth.uid == request.resource.data.hostId;

      allow update: if validAuth() && isTeacher() && request.resource.data.hostId == resource.data.hostId;

      match /rounds/{round} {
        function isTeacher() {
          return request.auth.uid == get(/databases/$(database)/documents/sessions/$(session)).data.hostId;
        }

        // A round can be written to by the teacher
        allow create, update: if validAuth() && isTeacher();

        // A round can be read by the teacher and students
        allow read: if validAuth() && (isTeacher() || isStudent());

        match /interactions/{interaction} {

          // Teachers and the student who created the interaction can read them
          allow read: if validAuth() && (isTeacher() || (isStudent() && resource.data.userId == request.auth.uid));

          // Interactions can only be created if the userId on the interaction matches the user adding them
          allow create: if validAuth() && isStudent() && request.resource.data.userId == request.auth.uid;
        }

        match /students/{student} {
          // A round student can be read by the teacher and the specific student
          allow read: if validAuth() && (isTeacher() || (isStudent() && request.auth.uid == student));
          // Only the teacher can create or update a round student
          allow create, update: if validAuth() && isTeacher();
        }

        match /hostEvents/{hostEvents} {
          // The host events are only created and read by the teacher
          allow create, read: if validAuth() && isTeacher();
        }
      }

      function hasCurrentRound() {
        let sessionData = get(/databases/$(database)/documents/sessions/$(session)).data;
        return ("currentRoundId" in sessionData) && sessionData.currentRoundId != null;
      }

      match /students/{student} {
        function isTeacher() {
          return request.auth.uid == get(/databases/$(database)/documents/sessions/$(session)).data.hostId;
        }

        // A session student can be read by the teacher and by that specific student.
        allow read: if validAuth() && (isTeacher() || request.auth.uid == student);

        // A session student must be created with the same ID as the user's UID
        // and while there is not currently a round running in the session.
        allow create: if validAuth() && request.auth.uid == student && !hasCurrentRound();

        // A session student can be updated or deleted by the teacher or that specific student
        // TODO: potentially check what is being changed on the student (eg name shouldn't be editable by student)
        allow update, delete: if validAuth() && (isTeacher() || request.auth.uid == student);
      }
    }
  }
}
